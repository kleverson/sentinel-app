package br.com.sentinelapp.core.data.security

import android.content.Context
import android.security.keystore.KeyGenParameterSpec
import android.security.keystore.KeyProperties
import android.util.Base64
import java.security.KeyStore
import java.security.SecureRandom
import javax.crypto.Cipher
import javax.crypto.KeyGenerator
import javax.crypto.SecretKey
import javax.crypto.spec.GCMParameterSpec
import javax.inject.Inject
import javax.inject.Singleton
import dagger.hilt.android.qualifiers.ApplicationContext
import androidx.core.content.edit

@Singleton
class KeyStoreManager @Inject constructor(
    @ApplicationContext private val context: Context
) {
    private val alias = "SENTINEL_APP_KEY"

    private val prefsName = "sentinel_keystore_prefs"
    private val prefPassphraseKey = "encrypted_passphrase"

    private val ANDROID_KEYSTORE = "AndroidKeyStore"
    private val AES_MODE = "AES/GCM/NoPadding"
    private val IV_SIZE = 12 // 96 bits for GCM recommended
    private val TAG_LENGTH = 128

    fun getOrCreateKey(): SecretKey {
        val keyStore = KeyStore.getInstance(ANDROID_KEYSTORE).apply {
            load(null)
        }

        keyStore.getKey(alias, null)?.let {
            return it as SecretKey
        }

        val generator = KeyGenerator.getInstance(
            KeyProperties.KEY_ALGORITHM_AES,
            ANDROID_KEYSTORE
        )

        generator.init(
            KeyGenParameterSpec.Builder(
                alias,
                KeyProperties.PURPOSE_ENCRYPT or KeyProperties.PURPOSE_DECRYPT
            )
                .setBlockModes(KeyProperties.BLOCK_MODE_GCM)
                .setEncryptionPaddings(KeyProperties.ENCRYPTION_PADDING_NONE)
                .build()
        )

        return generator.generateKey()
    }

    /**
     * Returns a stable random passphrase (ByteArray) used for SQLCipher.
     * The passphrase is generated once, encrypted with the AndroidKeyStore key and
     * stored in SharedPreferences.
     *
     * Supported stored formats:
     * - new: Base64( 1-byte ivLen | iv (ivLen bytes) | ciphertext )
     * - old: Base64( iv (IV_SIZE bytes) | ciphertext )
     */
    fun getOrCreatePassphrase(): ByteArray {
        val prefs = context.getSharedPreferences(prefsName, Context.MODE_PRIVATE)
        prefs.getString(prefPassphraseKey, null)?.let { stored ->
            try {
                val combined = Base64.decode(stored, Base64.NO_WRAP)
                if (combined.size > 0) {
                    // Try new format first (1-byte ivLen)
                    if (combined.size > 1) {
                        val ivLen = combined[0].toInt() and 0xFF
                        if (ivLen > 0 && combined.size >= 1 + ivLen + 1) {
                            val iv = combined.copyOfRange(1, 1 + ivLen)
                            val cipherText = combined.copyOfRange(1 + ivLen, combined.size)
                            val secretKey = getOrCreateKey()
                            return decryptWithKey(secretKey, iv, cipherText)
                        }
                    }

                    // Fallback to old format: iv (IV_SIZE) + ciphertext
                    if (combined.size > IV_SIZE) {
                        val iv = combined.copyOfRange(0, IV_SIZE)
                        val cipherText = combined.copyOfRange(IV_SIZE, combined.size)
                        val secretKey = getOrCreateKey()
                        return decryptWithKey(secretKey, iv, cipherText)
                    }
                }
            } catch (_: Throwable) {
                // failed to decode/decrypt - we'll fall through and generate a new passphrase
            }
        }

        // generate new random passphrase
        val passphrase = ByteArray(32).also { SecureRandom().nextBytes(it) }
        val secretKey = getOrCreateKey()
        val (iv, cipherText) = encryptWithKey(secretKey, passphrase)
        // Store as: 1-byte ivLen | iv | cipherText
        val combined = ByteArray(1 + iv.size + cipherText.size)
        combined[0] = iv.size.toByte()
        System.arraycopy(iv, 0, combined, 1, iv.size)
        System.arraycopy(cipherText, 0, combined, 1 + iv.size, cipherText.size)
        val encoded = Base64.encodeToString(combined, Base64.NO_WRAP)
        prefs.edit { putString(prefPassphraseKey, encoded) }
        return passphrase
    }

    private fun encryptWithKey(key: SecretKey, data: ByteArray): Pair<ByteArray, ByteArray> {
        val cipher = Cipher.getInstance(AES_MODE)
        // Let the AndroidKeyStore/provider generate a secure IV for encryption.
        cipher.init(Cipher.ENCRYPT_MODE, key)
        val iv = cipher.iv ?: throw IllegalStateException("IV not generated by cipher")
        val cipherText = cipher.doFinal(data)
        return iv to cipherText
    }

    private fun decryptWithKey(key: SecretKey, iv: ByteArray, cipherText: ByteArray): ByteArray {
        val cipher = Cipher.getInstance(AES_MODE)
        val spec = GCMParameterSpec(TAG_LENGTH, iv)
        cipher.init(Cipher.DECRYPT_MODE, key, spec)
        return cipher.doFinal(cipherText)
    }
}
